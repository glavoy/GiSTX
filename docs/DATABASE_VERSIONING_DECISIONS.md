# Database Versioning Design Decisions

**Document Created:** 2026-01-11
**Project:** DataKollecta (r21 branch)
**Status:** Decision Finalized

---

## The Problem

### Background

DataKollecta creates a SQLite database for each survey/CRF that is deployed. The database name was originally derived from the uploaded zip file name. For example:

- `r21_test_negative_2026-01-05.zip` → creates `r21_test_negative_2026-01-05.sqlite`
- `r21_test_negative_2026-01-08.zip` → creates `r21_test_negative_2026-01-08.sqlite`

### The Fundamental Design Flaw

When a survey is updated (e.g., adding new questions), a new zip file is created with a new name (typically with a new date). This causes the app to create a **new, empty database** for the updated survey version.

### Critical Impact: Subject ID Generation

The most serious consequence relates to subject ID (`subjid`) generation:

1. Subject IDs include an **auto-incrementing number** as a suffix (e.g., `R21-SITE01-0001`, `R21-SITE01-0002`)
2. This incremental number is generated by querying the database for the highest existing number and adding 1
3. With a **new empty database**, the counter resets to `0001`
4. This creates **duplicate subject IDs** across the old and new databases - a critical data integrity issue

### Example Scenario

```
Old database (r21_test_negative_2026-01-05.sqlite):
  - Contains subjects: R21-SITE01-0001, R21-SITE01-0002, R21-SITE01-0003

User upgrades to new survey version (r21_test_negative_2026-01-08.zip):
  - New database created: r21_test_negative_2026-01-08.sqlite (empty)
  - Next subject enrolled: R21-SITE01-0001  ← DUPLICATE!
```

---

## Options Considered

### Option 1: Parse Zip Filename to Extract Base Name

**Approach:** Modify app code to strip the date portion from the zip filename and use only the base name for the database (e.g., `r21_test_negative.sqlite`).

**Pros:**
- Automatic - no manual intervention for future versions
- Users cannot accidentally misconfigure it

**Cons:**
- Requires defining a parsing convention (what exactly constitutes the "base name"?)
- Fragile if naming conventions change in the future
- Removes flexibility - what if someone legitimately needs separate databases for different surveys?
- Requires code changes and testing

### Option 2: Explicitly Specify databaseName in Manifest

**Approach:** Use the `databaseName` field in `survey_manifest.gistx` to hardcode the database name, keeping it consistent across all future versions.

**Pros:**
- Simple - no code changes required
- Works immediately
- Explicit and clear about which database is being used
- Already supported by the current app design

**Cons:**
- Requires manual maintenance - must remember to set correctly in each new zip
- Error-prone if forgotten when creating new survey versions

### Option 3: Hybrid Approach with Project ID (Recommended for Future Projects)

**Approach:** Add a `projectId` field to the manifest that is explicitly designed to remain stable across survey versions.

**Proposed manifest structure:**
```json
{
  "projectId": "r21_test_negative",
  "surveyVersion": "2026-01-08",
  "databaseName": null
}
```

**Behavior:**
- If `databaseName` is null/missing, auto-generate as `{projectId}.sqlite`
- If `databaseName` is explicitly set, use that value (for edge cases)
- If `projectId` is missing, fall back to current behavior (backwards compatible)

**Pros:**
- Semantic clarity - `projectId` explicitly communicates "this identifies the project across versions"
- Intentional design - forces survey creators to think about project identity vs. version
- Backwards compatible - defaults to current behavior if `projectId` is missing
- Flexible - can still override with explicit `databaseName` for edge cases

**Cons:**
- Requires code changes
- Requires testing
- Overkill for a single-project branch

---

## Decision Made

### For the r21 Branch (This Branch)

**Decision:** Use Option 2 - Hardcode the database name in the manifest

**Implementation:**
- All future survey versions for this project will use:
  ```json
  "databaseName": "r21_test_negative_2026-01-05.sqlite"
  ```
- This value will remain unchanged **in perpetuity** for this branch
- The date `2026-01-05` in the filename is now meaningless - it's simply a stable identifier

**Rationale:**
1. This branch is dedicated to a single project (r21)
2. No new projects will be added to this branch
3. Zero code changes required
4. Zero risk of breaking existing functionality
5. Works immediately
6. Users are unaffected - they never see the database filename anyway

### For Future Projects (Other Branch)

**Decision:** Implement Option 3 - Hybrid approach with `projectId`

**Rationale:**
1. Proper architectural solution for multi-project scenarios
2. Makes design intent clear to future survey creators
3. Reduces human error in manifest configuration
4. Worth the development investment for a reusable solution

---

## Data Migration Considerations

### Why Migration is Complex for This App

Unlike desktop/server applications, DataKollecta runs on **Android phones used by end users**. This means:

1. Users cannot manually navigate to app directories
2. Users cannot copy/rename SQLite files themselves
3. Any migration must be **coded into the app** and be **completely transparent**

### Migration Strategy (If Ever Needed)

If the database name must change in the future, the migration code would need to:

1. On app startup, detect if the old database file exists
2. Copy the old database to the new filename
3. Verify the copy was successful
4. Handle edge cases:
   - Insufficient storage space
   - Copy failure mid-operation
   - Rollback capability if something goes wrong
5. Optionally delete the old database after successful migration
6. All of this must happen silently with no user interaction

### Current Decision: Avoid Migration

By keeping `r21_test_negative_2026-01-05.sqlite` as the permanent database name, we **completely avoid** the need for migration code. This is the safest approach because:

- No risk of data loss
- No edge cases to handle
- No additional code to write, test, and maintain
- No user confusion or support requests

---

## Implementation Checklist for Future Survey Updates

When creating a new version of the r21 survey:

- [ ] Create the new survey/CRF content
- [ ] Package into a new zip file (can use any filename, e.g., `r21_test_negative_2026-01-08.zip`)
- [ ] **CRITICAL:** Ensure `survey_manifest.gistx` contains:
  ```json
  "databaseName": "r21_test_negative_2026-01-05.sqlite"
  ```
- [ ] Verify this value has NOT been changed to match the new zip filename
- [ ] Test the update on a device with existing data to confirm data continuity

---

## File Reference

The manifest file location within the zip package:
```
{survey_name}.zip
  └── survey_manifest.gistx
```

Relevant field in `survey_manifest.gistx`:
```json
{
  "databaseName": "r21_test_negative_2026-01-05.sqlite",
  ...
}
```

---

## Summary

| Aspect | Decision |
|--------|----------|
| Branch | r21 (current) |
| Database name | `r21_test_negative_2026-01-05.sqlite` (permanent) |
| Approach | Option 2 - Hardcoded in manifest |
| Code changes required | None |
| Migration required | None |
| Future projects | Will use Option 3 (projectId) in separate branch |

---

## Schema Updates: Adding New Questions

### How It Works

The app automatically handles new questions added to the XML files. When a survey is loaded, the `DbService` compares the XML fields against existing database columns:

1. **If the table doesn't exist** (new database): Creates the table with all columns from the XML
2. **If the table already exists**:
   - Gets the list of existing columns
   - For each question field NOT in the database, runs `ALTER TABLE ... ADD COLUMN`
   - New columns are added as `TEXT` type
   - Existing data is preserved
   - New columns will be `NULL` for existing records

### Relevant Code

Located in `lib/services/db_service.dart`, method `_syncSurveyTable()` (lines 379-452):

```dart
} else {
  // Alter table logic
  final existingColumns = await _getTableColumns(db, tableName);
  for (final q in dataQuestions) {
    if (!existingColumns.contains(q.fieldName.toLowerCase())) {
      try {
        await db.execute(
            'ALTER TABLE $tableName ADD COLUMN ${q.fieldName} TEXT');
        _log('Added column ${q.fieldName} to $tableName');
      } catch (e) {
        _logError('Failed to add column ${q.fieldName}: $e');
      }
    }
  }
}
```

### What This Means

When you add new questions to the XML and deploy a new zip:
- The app reads the updated XML
- New fields are automatically added to the database
- Existing data is preserved
- No manual migration needed

**Note:** Removing questions from the XML does NOT remove columns from the database. Old columns remain but are simply unused.

---

## Date Display Format Issue

### The Problem

Dates are stored in the database in ISO format (`YYYY-MM-DD`), which is the international standard. However, Ugandan interviewers are accustomed to `DD/MM/YYYY` format.

When dates are displayed in question text using placeholders like `[[vx_dose1_date]]`, they appear as `2026-01-05` rather than `05/01/2026`.

### Example Question Affected

```xml
<text>Review and confirm the dates you have entered for malaria vaccine doses.

If any date is incorrect, please go back and correct it.

Dose 1: [[vx_dose1_date]]
Dose 2: [[vx_dose2_date]]
Dose 3: [[vx_dose3_date]]
Dose 4: [[vx_dose4_date]]</text>
```

### Options Considered

#### Option 1: Format Specifier in Brackets (Recommended for Future)

**Approach:** Add format specifier syntax: `[[vx_dose1_date:dd/mm/yyyy]]`

**Pros:**
- Elegant, flexible solution
- Format is explicit in the XML - self-documenting
- Could support multiple formats in future
- Single source of truth (date stored once in ISO format)

**Cons:**
- Requires code change
- Need to parse the format specifier
- Need to detect if field is actually a date

**Verdict:** Best long-term solution. Implement in the other branch or when next updating this branch.

#### Option 2: Store Date Twice

**Approach:** Store each date in both `YYYY-MM-DD` and `DD/MM/YYYY` formats.

**Pros:**
- No code change to display logic

**Cons:**
- Data duplication - violates normalization
- Risk of inconsistency if one gets updated and the other doesn't
- Doubles storage for every date field
- Clunky

**Verdict:** Avoid this approach.

#### Option 3: Add Format Hint in Question Text (Current Workaround)

**Approach:** Add explanatory text next to the date placeholder.

**Pros:**
- Zero code changes
- Can implement immediately
- Clear to interviewers

**Cons:**
- Interviewers still have to mentally parse the date
- Slightly cluttered UI

**Verdict:** Good immediate workaround.

#### Option 4: Global Date Display Setting

**Approach:** Add a setting in the manifest or app config that says "display all dates as DD/MM/YYYY".

**Pros:**
- One setting affects all dates consistently
- No XML changes needed per-field

**Cons:**
- Less flexible (can't mix formats)
- Still requires code change

**Verdict:** Consider for the other branch if all Ugandan projects want DD/MM/YYYY consistently.

### Decision Made

**For now (r21 branch):** Use Option 3 - Add format hints to question text

Update the XML to:
```xml
<text>Review and confirm the dates you have entered for malaria vaccine doses.

If any date is incorrect, please go back and correct it.

Dose 1: [[vx_dose1_date]] (Year-Month-Day)
Dose 2: [[vx_dose2_date]] (Year-Month-Day)
Dose 3: [[vx_dose3_date]] (Year-Month-Day)
Dose 4: [[vx_dose4_date]] (Year-Month-Day)</text>
```

Using "Year-Month-Day" instead of "YYYY-MM-DD" is clearer for non-technical users.

**For future (other branch):** Implement Option 1 - Format specifier syntax `[[field:format]]`

---

## Document History

| Date | Change |
|------|--------|
| 2026-01-11 | Initial document created |
| 2026-01-11 | Added schema update documentation and date display format issue |
